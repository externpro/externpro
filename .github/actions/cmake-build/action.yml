name: CMake Build
description: Configure and build using CMake presets and upload build artifacts.
inputs:
  artifact_pattern:
    required: true
  cmake_version:
    required: false
    default: "4.2.3"
  cmake_workflow_preset:
    required: true
  cmake_preset:
    required: true
  no_install_preset:
    required: true
  name_suffix:
    required: false
    default: ""
  enable_tmate:
    required: false
    default: "false"
runs:
  using: composite
  steps:
    -
      name: Install CMake
      uses: ssrobins/install-cmake@v1
      continue-on-error: true
      with:
        version: ${{ inputs.cmake_version }}
    -
      name: CMake Configure
      shell: bash
      run: |
        shopt -s nullglob
        files=(cmake-${{ inputs.cmake_version }}-*)
        if ((${#files[@]})); then
          rm -f "${files[@]}"
        fi
        cmake --version
        cmake --preset=${{ inputs.cmake_preset }}
    -
      name: Upload CMake logs
      uses: actions/upload-artifact@v4
      with:
        name: cmake-logs-${{ inputs.cmake_preset }}-${{ runner.arch }}${{ inputs.name_suffix }}
        path: |
          _bld-${{ inputs.cmake_preset }}/CMakeFiles/CMakeConfigureLog.yaml
    -
      name: CMake Workflow
      shell: bash
      id: cmake_workflow
      continue-on-error: true
      run: cmake --workflow --preset=${{ inputs.cmake_workflow_preset }}
    -
      name: Install tmate (on failure)
      if: ${{ inputs.enable_tmate == 'true' && steps.cmake_workflow.outcome == 'failure' }}
      shell: bash
      run: |
        if command -v tmate >/dev/null 2>&1; then
          exit 0
        fi
        install_tmate_static() {
          local ver="2.4.0"
          local arch
          arch=$(uname -m)
          local asset_arches
          case "$arch" in
            x86_64|amd64)
              asset_arches=("amd64")
              ;;
            aarch64|arm64)
              asset_arches=("arm64v8" "arm64")
              ;;
            *)
              echo "Unsupported architecture for static tmate download: ${arch}" >&2
              return 1
              ;;
          esac
          local tmpdir
          tmpdir=$(mktemp -d)
          local asset_arch
          for asset_arch in "${asset_arches[@]}"; do
            local url="https://github.com/tmate-io/tmate/releases/download/${ver}/tmate-${ver}-static-linux-${asset_arch}.tar.xz"
            if curl -fsSL "$url" -o "$tmpdir/tmate.tar.xz"; then
              tar -xJf "$tmpdir/tmate.tar.xz" -C "$tmpdir"
              local bin
              bin=$(find "$tmpdir" -type f -name tmate -perm -u+x | head -1)
              if [ -z "$bin" ]; then
                echo "Could not locate extracted tmate binary" >&2
                return 1
              fi
              sudo install -m 0755 "$bin" /usr/local/bin/tmate
              tmate -V || true
              return 0
            fi
          done
          echo "Could not download a static tmate binary for arch ${arch} (tried: ${asset_arches[*]})" >&2
          return 1
        }
        if command -v dnf >/dev/null 2>&1; then
          sudo dnf -y install openssh-clients || true
          sudo dnf -y install tmate || (sudo dnf -y install epel-release && sudo dnf -y install tmate) || install_tmate_static
        elif command -v yum >/dev/null 2>&1; then
          sudo yum -y install openssh-clients || true
          sudo yum -y install tmate || (sudo yum -y install epel-release && sudo yum -y install tmate) || install_tmate_static
        elif command -v apt-get >/dev/null 2>&1; then
          sudo apt-get update
          sudo apt-get install -y tmate openssh-client
        else
          echo "No supported package manager found to install tmate" >&2
          exit 1
        fi
        if ! command -v tmate >/dev/null 2>&1; then
          echo "tmate was not installed successfully" >&2
          exit 1
        fi
    -
      name: Setup tmate session (on failure)
      if: ${{ inputs.enable_tmate == 'true' && steps.cmake_workflow.outcome == 'failure' }}
      uses: mxschmitt/action-tmate@v3
      with:
        install-dependencies: false
    -
      name: Fail if CMake Workflow failed
      if: ${{ steps.cmake_workflow.outcome == 'failure' }}
      shell: bash
      run: exit 1
    -
      name: Find package
      id: find_package
      if: ${{ inputs.cmake_workflow_preset != inputs.no_install_preset }}
      shell: bash
      run: |
        file=$(pwd)/$(ls _bld-${{ inputs.cmake_preset }}/${{ inputs.artifact_pattern }})
        if [[ ! -f "$file" ]]; then
          echo "::error::Package not found!" >&2
          exit 1
        fi
        echo "filepath=$file" >> $GITHUB_OUTPUT
        echo "filename=$(basename $file)" >> $GITHUB_OUTPUT
      working-directory: ${{ github.workspace }}
    -
      name: Find manifest
      id: find_manifest
      if: ${{ inputs.cmake_workflow_preset != inputs.no_install_preset }}
      shell: bash
      run: |
        build_dir=_bld-${{ inputs.cmake_preset }}
        default_artifact_pattern="${{ github.event.repository.name }}-*-xpro.tar.xz"
        manifest_required=true
        if [[ "${{ inputs.artifact_pattern }}" != "$default_artifact_pattern" ]]; then
          manifest_required=false
        fi
        rel_file=$(find "$build_dir" -type f -name "${{ github.event.repository.name }}-*.manifest.cmake" | head -1)
        if [[ -z "$rel_file" ]]; then
          echo "found=false" >> $GITHUB_OUTPUT
          if [[ "$manifest_required" == "true" ]]; then
            echo "::error::Manifest not found!" >&2
            ls -la "$build_dir" || true
            exit 1
          fi
          exit 0
        fi
        file=$(pwd)/$rel_file
        if [[ ! -f "$file" ]]; then
          echo "found=false" >> $GITHUB_OUTPUT
          if [[ "$manifest_required" == "true" ]]; then
            echo "::error::Manifest not found!" >&2
            ls -la "$build_dir" || true
            exit 1
          fi
          exit 0
        fi
        echo "found=true" >> $GITHUB_OUTPUT
        echo "filepath=$file" >> $GITHUB_OUTPUT
        echo "filename=$(basename $file)" >> $GITHUB_OUTPUT
      working-directory: ${{ github.workspace }}
    -
      name: Convert Git Bash paths to Windows paths
      id: convert_paths
      if: ${{ inputs.cmake_workflow_preset != inputs.no_install_preset && runner.os == 'Windows' }}
      shell: pwsh
      run: |
        $pkgWindowsPath = '${{ steps.find_package.outputs.filepath }}' -replace '^/([a-zA-Z])/', '$1:/' -replace '/', '\\'
        $manifestWindowsPath = '${{ steps.find_manifest.outputs.filepath }}' -replace '^/([a-zA-Z])/', '$1:/' -replace '/', '\\'
        echo "package_windows_path=$pkgWindowsPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        echo "manifest_windows_path=$manifestWindowsPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
    -
      name: Upload package artifact
      if: ${{ inputs.cmake_workflow_preset != inputs.no_install_preset && inputs.name_suffix != '-ubuntu' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.find_package.outputs.filename }}
        path: ${{ runner.os == 'Windows' && steps.convert_paths.outputs.package_windows_path || steps.find_package.outputs.filepath }}
    -
      name: Upload manifest artifact
      if: ${{ inputs.cmake_workflow_preset != inputs.no_install_preset && steps.find_manifest.outputs.found == 'true' && inputs.name_suffix != '-ubuntu' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.find_manifest.outputs.filename }}-${{ inputs.cmake_preset }}-${{ runner.arch }}${{ inputs.name_suffix }}
        path: ${{ runner.os == 'Windows' && steps.convert_paths.outputs.manifest_windows_path || steps.find_manifest.outputs.filepath }}
    -
      name: Check for dirty repo
      shell: bash
      run: |
        if [ -n "$(git status --porcelain)" ]; then
          echo "::error::Dirty repo detected!"
          git status
          echo "--- git diff --name-status"
          git --no-pager diff --name-status
          echo "--- git diff --stat"
          git --no-pager diff --stat
          echo "--- git diff"
          git --no-pager diff

          echo "--- submodule status"
          git submodule status --recursive || true
          git submodule foreach --recursive 'echo "--- submodule: $name"; git status; git --no-pager diff --name-status; git --no-pager diff || true'
          exit 1
        fi
