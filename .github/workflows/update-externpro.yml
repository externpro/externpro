name: Update externpro Submodule
on:
  workflow_call:
    inputs:
      submodule_path:
        description: 'Path to externpro submodule'
        required: false
        type: string
        default: '.devcontainer'
      target_ref:
        description: 'Branch or tag to update externpro to (e.g., "main" or "25.07.4")'
        required: false
        type: string
        default: 'main'
      preserve_existing_branches:
        description: 'Whether to preserve existing branches in caller workflows (default: use branches from wf-templates)'
        required: false
        type: boolean
        default: false
      create_missing_workflows:
        description: 'Whether to create new workflow files in the caller repo when templates add them'
        required: false
        type: boolean
        default: true
      build_container:
        description: 'Build container image ghcr.io/{owner_repo}/bldimg-{arch}-{build_container}:latest'
        required: false
        type: string
        default: 'rocky9-gcc13'
      create_pr:
        description: 'Whether to create a pull request'
        required: false
        type: boolean
        default: true
      submodule_dependency_push_target:
        description: 'Where to push externpro submodule dependency artifact commits: "automation" or "main"'
        required: false
        type: string
        default: 'main'
    secrets:
      workflow_write_token:
        description: 'Optional token with permission to update .github/workflows (PAT or fine-grained token). If not set, uses GITHUB_TOKEN.'
        required: false
jobs:
  externpro:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      packages: read
    env:
      DEPENDENCY_FILES: "xprodeps.md xprodeps.svg"
      SUBMODULE_DEP_FILES: "cmake/README.md cmake/deps.svg"
    steps:
      -
        name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # fetches all history
          fetch-tags: true # explicitly fetches tags
          submodules: true
          token: ${{ github.token }}
      -
        name: Validate externpro submodule
        id: validate
        run: |
          SUBMODULE_PATH="${{ inputs.submodule_path }}"
          # Check if .gitmodules exists
          if [ ! -f ".gitmodules" ]; then
            echo "Error: .gitmodules file not found"
            exit 1
          fi
          # Check if submodule exists in .gitmodules
          if ! grep -q "path = $SUBMODULE_PATH" .gitmodules; then
            echo "Error: Submodule path $SUBMODULE_PATH not found in .gitmodules"
            exit 1
          fi
          # Check if submodule directory exists
          if [ ! -d "$SUBMODULE_PATH" ]; then
            echo "Error: Submodule directory $SUBMODULE_PATH does not exist"
            exit 1
          fi
          # Check if it's actually a git repository (submodule)
          if [ ! -e "$SUBMODULE_PATH/.git" ]; then
            echo "Error: $SUBMODULE_PATH is not a git submodule"
            exit 1
          fi
          if ! git -C "$SUBMODULE_PATH" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
            echo "Error: $SUBMODULE_PATH is not a valid git work tree"
            exit 1
          fi
          # Get submodule URL to verify it's externpro
          SUBMODULE_URL=$(git config -f .gitmodules --get submodule.$SUBMODULE_PATH.url)
          if [[ "$SUBMODULE_URL" != *"externpro/externpro"* ]]; then
            echo "Error: Submodule URL does not point to externpro/externpro: $SUBMODULE_URL"
            exit 1
          fi
          echo "✓ externpro submodule validation passed"
          echo "submodule_path=$SUBMODULE_PATH" >> $GITHUB_OUTPUT
      -
        name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git -C "${{ steps.validate.outputs.submodule_path }}" config user.name "github-actions[bot]"
          git -C "${{ steps.validate.outputs.submodule_path }}" config user.email "github-actions[bot]@users.noreply.github.com"
      -
        name: Get current externpro HEAD
        id: current_head
        run: |
          cd "${{ steps.validate.outputs.submodule_path }}"
          CURRENT_HEAD=$(git rev-parse HEAD)
          echo "current_head=$CURRENT_HEAD" >> $GITHUB_OUTPUT
          echo "Current externpro HEAD: $CURRENT_HEAD"
      -
        name: Update externpro submodule
        id: update
        run: |
          cd "${{ steps.validate.outputs.submodule_path }}"
          TARGET_REF="${{ inputs.target_ref }}"
          # Fetch latest changes
          git fetch origin
          # Check if target_ref is a tag or branch
          if git rev-parse --verify "origin/$TARGET_REF" >/dev/null 2>&1; then
            # It's a branch
            TARGET_TYPE="branch"
            echo "target_type=branch" >> $GITHUB_OUTPUT
            LATEST_HEAD=$(git rev-parse origin/"$TARGET_REF")
          elif git rev-parse --verify "$TARGET_REF" >/dev/null 2>&1; then
            # It's a tag or commit
            LATEST_HEAD=$(git rev-parse "$TARGET_REF")
            TARGET_TYPE="tag"
            echo "target_type=tag" >> $GITHUB_OUTPUT
          else
            echo "Error: Target ref '$TARGET_REF' not found"
            exit 1
          fi
          echo "latest_head=$LATEST_HEAD" >> $GITHUB_OUTPUT
          echo "Target ref: $TARGET_REF ($TARGET_TYPE)"
          echo "Latest externpro HEAD: $LATEST_HEAD"
          # Check if update is needed
          if [ "${{ steps.current_head.outputs.current_head }}" = "$LATEST_HEAD" ]; then
            echo "externpro submodule is already at target ref"
            echo "update_needed=false" >> $GITHUB_OUTPUT
          else
            echo "externpro submodule needs update"
            echo "update_needed=true" >> $GITHUB_OUTPUT
            # Update to target
            if [ "$TARGET_TYPE" = "branch" ]; then
              git checkout -B "$TARGET_REF" "origin/$TARGET_REF"
            else
              git checkout --detach "$LATEST_HEAD"
            fi
          fi
      -
        name: Get externpro version tag
        id: version
        run: |
          cd "${{ steps.validate.outputs.submodule_path }}"
          VERSION_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "no-tag")
          DESCRIBE=$(git describe --tags 2>/dev/null || git rev-parse --short HEAD)
          echo "version_tag=$VERSION_TAG" >> $GITHUB_OUTPUT
          echo "describe=$DESCRIBE" >> $GITHUB_OUTPUT
          echo "externpro version: $VERSION_TAG"
          echo "externpro describe: $DESCRIBE"
      -
        name: Create release-tag intent (if missing)
        id: release_intent
        if: ${{ always() && inputs.create_pr }}
        shell: bash
        run: |
          set -euo pipefail
          INTENT_FILE=".github/release-tag.yml"
          if [ -f "${INTENT_FILE}" ]; then
            BASE_TAG=$(grep -E '^tag:' "${INTENT_FILE}" | head -1 | sed -E 's/^tag:[[:space:]]*//')
            BASE_TAG=$(printf '%s' "${BASE_TAG}" | tr -d '\r' | xargs)
            echo "intent_created=false" >> "$GITHUB_OUTPUT"
          else
            mkdir -p .github
            set +e
            BASE_TAG=$(git describe --tags --abbrev=0 --match 'xpv*' 2>/dev/null)
            RC=$?
            set -e
            if [ $RC -ne 0 ] || [ -z "${BASE_TAG}" ]; then
              set +e
              BASE_TAG=$(git describe --tags --abbrev=0 --match 'v*' 2>/dev/null)
              RC=$?
              set -e
            fi
            if [ $RC -ne 0 ] || [ -z "${BASE_TAG}" ]; then
              BASE_TAG=$(git describe --tags --abbrev=0 2>/dev/null || true)
            fi
            if [ -z "${BASE_TAG}" ]; then
              BASE_TAG="xpv0.0.0"
            fi
            BASE_VERSION="${BASE_TAG#xpv}"
            BASE_VERSION="${BASE_VERSION#v}"
            {
              echo "tag: ${BASE_TAG}"
              echo "message: \"externpro version ${BASE_VERSION} tag\""
            } > "${INTENT_FILE}"
            git add "${INTENT_FILE}"
            echo "intent_created=true" >> "$GITHUB_OUTPUT"
          fi
          echo "intent_file=${INTENT_FILE}" >> "$GITHUB_OUTPUT"
          echo "intent_tag=${BASE_TAG}" >> "$GITHUB_OUTPUT"
          if [ -n "${BASE_TAG}" ] && git rev-parse -q --verify "refs/tags/${BASE_TAG}" >/dev/null 2>&1; then
            echo "intent_tag_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "intent_tag_exists=false" >> "$GITHUB_OUTPUT"
          fi
      -
        name: Update caller workflows
        id: update_workflows
        if: ${{ always() && inputs.create_pr }}
        uses: ./.devcontainer/.github/actions/sync-caller-workflows
        with:
          workflow_dir: .github/workflows
          template_dir: ${{ steps.validate.outputs.submodule_path }}/.github/wf-templates
          preserve_existing_branches: ${{ inputs.preserve_existing_branches }}
          create_missing_workflows: ${{ inputs.create_missing_workflows }}
      -
        name: Lowercase repository names (for container image)
        id: names
        run: |
          OWN_REPO_NAME=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')
          echo "owner_repo=${OWN_REPO_NAME}" >> "$GITHUB_OUTPUT"
      -
        name: Log in to GitHub Container Registry (for CMake configure)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}
      -
        name: Snapshot submodule dependency artifacts (pre-configure)
        id: submodule_deps_pre
        if: ${{ inputs.create_pr }}
        shell: bash
        run: |
          set -euo pipefail
          SUBMODULE_PATH="${{ steps.validate.outputs.submodule_path }}"
          hash_files() {
            local base="$1"
            shift
            local files=("$@")
            local tmp
            tmp=$(mktemp)
            : > "$tmp"
            for rel in "${files[@]}"; do
              local p="$base/$rel"
              if [ ! -f "$p" ]; then
                printf '%s\n' "$rel:MISSING" >> "$tmp"
                continue
              fi
              if command -v sha256sum >/dev/null 2>&1; then
                printf '%s\n' "$rel:$(sha256sum "$p" | awk '{print $1}')" >> "$tmp"
              else
                printf '%s\n' "$rel:$(shasum -a 256 "$p" | awk '{print $1}')" >> "$tmp"
              fi
            done
            if command -v sha256sum >/dev/null 2>&1; then
              sha256sum "$tmp" | awk '{print $1}'
            else
              shasum -a 256 "$tmp" | awk '{print $1}'
            fi
            rm -f "$tmp"
          }
          read -r -a DEP_ARR <<< "${SUBMODULE_DEP_FILES}"
          PRE_HASH=$(hash_files "$SUBMODULE_PATH" "${DEP_ARR[@]}")
          echo "pre_hash_sha256=$PRE_HASH" >> "$GITHUB_OUTPUT"
          echo "submodule_dep_files=${SUBMODULE_DEP_FILES}" >> "$GITHUB_OUTPUT"
          echo "pre-configure submodule combined hash: $PRE_HASH"
      -
        name: CMake Configure (container)
        id: cmake_configure
        shell: bash
        run: |
          set -euo pipefail
          echo "runner.arch=${{ runner.arch }}"
          case "${{ runner.arch }}" in
            X64)
              ARCH=amd64
              ;;
            ARM64)
              ARCH=arm64
              ;;
            *)
              echo "Unsupported runner.arch '${{ runner.arch }}' (expected X64 or ARM64)" >&2
              exit 1
              ;;
          esac
          IMAGE="ghcr.io/${{ steps.names.outputs.owner_repo }}/bldimg-${ARCH}-${{ inputs.build_container }}:latest"
          echo "Running CMake configure in container: ${IMAGE}"
          if ! docker manifest inspect "${IMAGE}" >/dev/null 2>&1; then
            echo "Container image not found or not accessible: ${IMAGE}" >&2
            exit 1
          fi
          echo "--- dependency files before"
          ls -la $DEPENDENCY_FILES 2>/dev/null || true
          set +e
          docker run --rm \
            --entrypoint bash \
            --hostname "${{ inputs.build_container }}" \
            --user "$(id -u):$(id -g)" \
            --volume "$GITHUB_WORKSPACE:/work" \
            --workdir /work \
            "${IMAGE}" \
            -lc "set -euo pipefail; \
              echo '=== cmake configure: begin ==='; \
              echo \"user=$(id -u):$(id -g)\"; \
              echo \"pwd=$(pwd)\"; \
              ls -la; \
              echo '--- cmake diagnostics'; \
              command -v cmake || { echo 'cmake not found in container' >&2; exit 127; }; \
              cmake --version; \
              echo '--- running: cmake --preset=Linux --log-level=VERBOSE'; \
              cmake --preset=Linux --log-level=VERBOSE; \
              echo '=== cmake configure: end ==='" 2>&1 | tee /tmp/cmake-configure.log
          DOCKER_RC=${PIPESTATUS[0]}
          echo "docker run exit code: ${DOCKER_RC}"
          set -e
          if [ "${DOCKER_RC}" -ne 0 ]; then
            exit "${DOCKER_RC}"
          fi
          echo "--- dependency files after"
          ls -la $DEPENDENCY_FILES 2>/dev/null || true
          echo "--- submodule dirtiness after configure"
          git -C "${{ steps.validate.outputs.submodule_path }}" status --porcelain || true
          echo "--- submodule diff after configure (name-status)"
          git -C "${{ steps.validate.outputs.submodule_path }}" diff --name-status -- ${SUBMODULE_DEP_FILES} 2>/dev/null || true
          echo "--- repo dirtiness after configure (before staging)"
          git status --porcelain || true
          for file in $DEPENDENCY_FILES; do
            if [ -e "$file" ]; then
              git add "$file"
            fi
          done
          echo "--- repo dirtiness after staging dependency files"
          git status --porcelain || true
          echo "--- staged changes (name-status)"
          git diff --cached --name-status -- $DEPENDENCY_FILES || true
          DEPENDENCY_STAGED_FILES=$(git diff --cached --name-only -- $DEPENDENCY_FILES || true)
          if [ -n "$DEPENDENCY_STAGED_FILES" ]; then
            echo "dependency_updated=true" >> "$GITHUB_OUTPUT"
            echo "dependency_files<<EOF" >> "$GITHUB_OUTPUT"
            echo "$DEPENDENCY_STAGED_FILES" >> "$GITHUB_OUTPUT"
            echo "EOF" >> "$GITHUB_OUTPUT"
          else
            echo "dependency_updated=false" >> "$GITHUB_OUTPUT"
          fi
      -
        name: Commit dependency artifacts in submodule
        id: commit_submodule_dependencies
        if: ${{ inputs.create_pr && steps.cmake_configure.outcome == 'success' }}
        shell: bash
        run: |
          set -euo pipefail
          SUBMODULE_PATH="${{ steps.validate.outputs.submodule_path }}"
          # xpProDeps()-specific case: generated dependency artifacts live in the externpro submodule
          SUBMODULE_DEP_FILES="${{ steps.submodule_deps_pre.outputs.submodule_dep_files }}"
          hash_files() {
            local base="$1"
            shift
            local files=("$@")
            local tmp
            tmp=$(mktemp)
            : > "$tmp"
            for rel in "${files[@]}"; do
              local p="$base/$rel"
              if [ ! -f "$p" ]; then
                printf '%s\n' "$rel:MISSING" >> "$tmp"
                continue
              fi
              if command -v sha256sum >/dev/null 2>&1; then
                printf '%s\n' "$rel:$(sha256sum "$p" | awk '{print $1}')" >> "$tmp"
              else
                printf '%s\n' "$rel:$(shasum -a 256 "$p" | awk '{print $1}')" >> "$tmp"
              fi
            done
            if command -v sha256sum >/dev/null 2>&1; then
              sha256sum "$tmp" | awk '{print $1}'
            else
              shasum -a 256 "$tmp" | awk '{print $1}'
            fi
            rm -f "$tmp"
          }
          read -r -a DEP_ARR <<< "${SUBMODULE_DEP_FILES}"
          PRE_HASH="${{ steps.submodule_deps_pre.outputs.pre_hash_sha256 }}"
          POST_HASH=$(hash_files "$SUBMODULE_PATH" "${DEP_ARR[@]}")
          if [ "$PRE_HASH" = "$POST_HASH" ]; then
            echo "No submodule dependency artifact changes produced by configure"
            echo "submodule_dependency_commit=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "--- submodule dirtiness at commit time"
          git -C "$SUBMODULE_PATH" status --porcelain || true
          echo "--- submodule diff at commit time (name-status)"
          git -C "$SUBMODULE_PATH" diff --name-status -- $SUBMODULE_DEP_FILES 2>/dev/null || true
          echo "--- submodule README header at commit time"
          sed -n '1,8p' "$SUBMODULE_PATH/cmake/README.md" 2>/dev/null || true
          echo "--- submodule dependency files before"
          (cd "$SUBMODULE_PATH" && ls -la $SUBMODULE_DEP_FILES 2>/dev/null) || true
          if git -C "$SUBMODULE_PATH" diff --quiet -- $SUBMODULE_DEP_FILES 2>/dev/null && git -C "$SUBMODULE_PATH" diff --cached --quiet -- $SUBMODULE_DEP_FILES 2>/dev/null; then
            echo "No submodule dependency artifact changes detected"
            echo "submodule_dependency_commit=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          git -C "$SUBMODULE_PATH" add -- $SUBMODULE_DEP_FILES || true
          if git -C "$SUBMODULE_PATH" diff --cached --quiet -- $SUBMODULE_DEP_FILES; then
            echo "No submodule dependency artifact changes staged"
            echo "submodule_dependency_commit=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          git -C "$SUBMODULE_PATH" commit -m "dependency updates" -- $SUBMODULE_DEP_FILES
          echo "submodule_dependency_commit=true" >> "$GITHUB_OUTPUT"
          echo "✓ committed dependency artifacts in submodule"
          PUSH_TARGET="${{ inputs.submodule_dependency_push_target }}"
          SUBMODULE_PUSH_TOKEN="${{ secrets.workflow_write_token || github.token }}"
          if [ -z "${SUBMODULE_PUSH_TOKEN}" ]; then
            echo "Error: missing token for pushing submodule commit (workflow_write_token/github.token empty)" >&2
            exit 1
          fi
          git -C "$SUBMODULE_PATH" remote set-url origin "https://x-access-token:${SUBMODULE_PUSH_TOKEN}@github.com/externpro/externpro.git"
          case "$PUSH_TARGET" in
            main)
              if [ "${{ inputs.target_ref }}" != "main" ] || [ "${{ steps.update.outputs.target_type }}" != "branch" ]; then
                echo "Error: submodule_dependency_push_target=main requires inputs.target_ref=main (branch)" >&2
                exit 1
              fi
              echo "Pushing submodule commit to origin/main"
              git -C "$SUBMODULE_PATH" push origin HEAD:refs/heads/main
              echo "submodule_dependency_push_ref=main" >> "$GITHUB_OUTPUT"
              ;;
            automation|*)
              SUB_BRANCH="xpupdate-deps-${{ github.run_id }}-${{ github.run_attempt }}"
              echo "submodule_dependency_branch=$SUB_BRANCH" >> "$GITHUB_OUTPUT"
              echo "Pushing submodule commit to origin as branch '$SUB_BRANCH'"
              git -C "$SUBMODULE_PATH" push origin HEAD:refs/heads/"$SUB_BRANCH"
              echo "submodule_dependency_push_ref=$SUB_BRANCH" >> "$GITHUB_OUTPUT"
              ;;
          esac
      -
        name: Get final externpro version/head
        id: final_version
        run: |
          cd "${{ steps.validate.outputs.submodule_path }}"
          FINAL_HEAD=$(git rev-parse HEAD)
          VERSION_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "no-tag")
          DESCRIBE=$(git describe --tags 2>/dev/null || git rev-parse --short HEAD)
          echo "final_head=$FINAL_HEAD" >> $GITHUB_OUTPUT
          echo "version_tag=$VERSION_TAG" >> $GITHUB_OUTPUT
          echo "describe=$DESCRIBE" >> $GITHUB_OUTPUT
          echo "externpro final head: $FINAL_HEAD"
          echo "externpro final version: $VERSION_TAG"
          echo "externpro final describe: $DESCRIBE"
      -
        name: Stage submodule pointer update
        id: stage_submodule
        if: ${{ always() && inputs.create_pr }}
        run: |
          # Stage submodule pointer update after any submodule commits (and/or after switching target ref)
          git add "${{ steps.validate.outputs.submodule_path }}"
          if git diff --cached --quiet -- "${{ steps.validate.outputs.submodule_path }}"; then
            echo "✓ No submodule pointer changes staged for ${{ steps.validate.outputs.submodule_path }}"
          else
            echo "✓ Staged submodule pointer update for ${{ steps.validate.outputs.submodule_path }}"
          fi
      -
        name: Determine if PR is needed
        id: pr_needed
        if: inputs.create_pr
        run: |
          if git diff --cached --quiet; then
            echo "pr_needed=false" >> $GITHUB_OUTPUT
            echo "No staged changes (no PR needed)"
          else
            echo "pr_needed=true" >> $GITHUB_OUTPUT
            echo "Staged changes detected (PR needed)"
          fi
      -
        name: Create branch
        id: branch
        if: inputs.create_pr && steps.pr_needed.outputs.pr_needed == 'true'
        run: |
          DESCRIBE="${{ steps.final_version.outputs.describe }}"
          # Clean describe for branch name (remove invalid chars)
          CLEAN_DESCRIBE="$(echo "$DESCRIBE" | sed 's/[^a-zA-Z0-9.-]/-/g')"
          # Include a unique suffix so reruns don't collide on the same describe.
          UNIQUE_SUFFIX="${{ github.run_id }}-${{ github.run_attempt }}"
          BRANCH_NAME="externpro-update-${CLEAN_DESCRIBE}-${UNIQUE_SUFFIX}"
          git checkout -b "$BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
      -
        name: Commit submodule update
        if: steps.update.outputs.update_needed == 'true' && inputs.create_pr && steps.pr_needed.outputs.pr_needed == 'true'
        run: |
          COMMIT_MSG="externpro ${{ steps.final_version.outputs.describe }}"
          git commit -m "$COMMIT_MSG" -- "${{ steps.validate.outputs.submodule_path }}"
          echo "Commit created: $COMMIT_MSG"
      -
        name: Commit dependency updates
        if: inputs.create_pr && steps.pr_needed.outputs.pr_needed == 'true'
        run: |
          FILES=$(git diff --cached --name-only -- $DEPENDENCY_FILES || true)
          if [ -z "$FILES" ]; then
            echo "No dependency changes staged"
            exit 0
          fi
          git commit -m "dependency updates" -- $FILES
      -
        name: Commit release-tag intent
        if: inputs.create_pr && steps.pr_needed.outputs.pr_needed == 'true' && steps.release_intent.outputs.intent_created == 'true'
        run: |
          INTENT_FILE="${{ steps.release_intent.outputs.intent_file }}"
          if [ -z "${INTENT_FILE}" ] || [ ! -f "${INTENT_FILE}" ]; then
            echo "release-tag intent file missing; nothing to commit"
            exit 0
          fi
          if git diff --cached --quiet -- "${INTENT_FILE}"; then
            echo "release-tag intent not staged; nothing to commit"
            exit 0
          fi
          git commit -m "add release-tag intent" -- "${INTENT_FILE}"
      -
        name: Commit and push workflow updates
        if: inputs.create_pr && steps.pr_needed.outputs.pr_needed == 'true'
        run: |
          TOKEN="${{ secrets.workflow_write_token }}"
          if [ -z "${TOKEN}" ]; then
            TOKEN="${{ github.token }}"
          fi
          git remote set-url origin "https://x-access-token:${TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          if ! git diff --cached --quiet; then
            COMMIT_MSG="externpro ${{ steps.final_version.outputs.describe }} workflow updates"
            git commit -m "$COMMIT_MSG"
            echo "Commit created: $COMMIT_MSG"
          fi
          git push --set-upstream origin "${{ steps.branch.outputs.branch_name }}"
      -
        name: Create Pull Request
        if: inputs.create_pr && steps.pr_needed.outputs.pr_needed == 'true'
        run: |
          set -euo pipefail
          GH_TOKEN="${{ secrets.workflow_write_token }}"
          if [ -z "${GH_TOKEN}" ]; then
            GH_TOKEN="${{ github.token }}"
          fi
          export GH_TOKEN
          WORKFLOW_REPORT="${{ steps.update_workflows.outputs.workflow_report }}"
          gh_retry() {
            local max_attempts=6
            local attempt=1
            local delay=5
            local out
            while true; do
              set +e
              out=$("$@" 2>&1)
              local rc=$?
              set -e
              if [ $rc -eq 0 ]; then
                printf '%s' "$out"
                return 0
              fi
              if echo "$out" | grep -q "HTTP 429"; then
                if [ $attempt -ge $max_attempts ]; then
                  printf '%s\n' "$out" >&2
                  return $rc
                fi
                printf '%s\n' "$out" >&2
                sleep "$delay"
                attempt=$((attempt + 1))
                delay=$((delay * 2))
                continue
              fi
              printf '%s\n' "$out" >&2
              return $rc
            done
          }
          BASE_BRANCH="${{ github.event.repository.default_branch }}"
          HEAD_BRANCH="${{ steps.branch.outputs.branch_name }}"
          export HEAD_BRANCH
          TITLE="externpro ${{ steps.final_version.outputs.describe }}"
          BODY_FILE="/tmp/pr-body.md"
          : > "$BODY_FILE"
          echo "## Summary" >> "$BODY_FILE"
          echo >> "$BODY_FILE"
          if [ "${{ steps.update.outputs.update_needed }}" = "true" ]; then
            echo "Update externpro submodule to \`${{ steps.final_version.outputs.describe }}\`" >> "$BODY_FILE"
          else
            echo "Sync caller workflows from templates" >> "$BODY_FILE"
          fi
          echo >> "$BODY_FILE"
          echo "## Changes" >> "$BODY_FILE"
          echo >> "$BODY_FILE"
          if [ "${{ steps.update.outputs.update_needed }}" = "true" ]; then
            echo "- Updated \`${{ steps.validate.outputs.submodule_path }}\` to externpro \`${{ steps.final_version.outputs.describe }}\`" >> "$BODY_FILE"
            echo "- Previous HEAD: \`${{ steps.current_head.outputs.current_head }}\`" >> "$BODY_FILE"
            echo "- New HEAD: \`${{ steps.final_version.outputs.final_head }}\`" >> "$BODY_FILE"
            if [ "${{ steps.final_version.outputs.final_head }}" != "${{ steps.update.outputs.latest_head }}" ]; then
              echo "  - Target ref HEAD: \`${{ steps.update.outputs.latest_head }}\`" >> "$BODY_FILE"
            fi
          fi
          if [ "${{ steps.cmake_configure.outputs.dependency_updated }}" = "true" ]; then
            echo "- Updated dependency files" >> "$BODY_FILE"
            if [ -n "${{ steps.cmake_configure.outputs.dependency_files }}" ]; then
              echo "  - Files:" >> "$BODY_FILE"
              while IFS= read -r f; do
                [ -n "$f" ] && echo "    - \`$f\`" >> "$BODY_FILE"
              done < <(printf '%s\n' "${{ steps.cmake_configure.outputs.dependency_files }}")
            fi
          fi
          if [ "${{ steps.commit_submodule_dependencies.outputs.submodule_dependency_commit }}" = "true" ]; then
            echo "- Updated externpro submodule dependency artifacts (pushed to \`${{ steps.commit_submodule_dependencies.outputs.submodule_dependency_push_ref }}\`)" >> "$BODY_FILE"
          fi
          if [ "${{ steps.release_intent.outputs.intent_created }}" = "true" ]; then
            echo "- Created \`.github/release-tag.yml\` (tag: \`${{ steps.release_intent.outputs.intent_tag }}\`)" >> "$BODY_FILE"
          fi
          if [ -n "${{ steps.release_intent.outputs.intent_tag }}" ]; then
            echo "- If you add the \\\"release:tag\\\" label, the tag will be \\\`${{ steps.release_intent.outputs.intent_tag }}\\\`" >> "$BODY_FILE"
            if [ "${{ steps.release_intent.outputs.intent_tag_exists }}" = "true" ]; then
              echo "  - WARNING: that tag already exists; update \\\".github/release-tag.yml\\\" to the next desired tag value" >> "$BODY_FILE"
              echo "    - https://github.com/${{ github.repository }}/blob/$HEAD_BRANCH/.github/release-tag.yml" >> "$BODY_FILE"
            fi
          fi
          if [ "${{ steps.update_workflows.outputs.workflows_updated }}" = "true" ]; then
            echo "- Updated caller workflows to match templates" >> "$BODY_FILE"
          fi
          if [ -n "${WORKFLOW_REPORT}" ]; then
            echo >> "$BODY_FILE"
            echo "### Workflow Update Report" >> "$BODY_FILE"
            echo >> "$BODY_FILE"
            printf '%s\n' "$WORKFLOW_REPORT" >> "$BODY_FILE"
          fi
          echo >> "$BODY_FILE"
          echo "---" >> "$BODY_FILE"
          echo >> "$BODY_FILE"
          echo "*This PR was created automatically by GitHub Actions*" >> "$BODY_FILE"
          if gh_retry gh pr view "$HEAD_BRANCH" --json url --jq .url >/dev/null 2>&1; then
            PR_URL=$(gh_retry gh pr view "$HEAD_BRANCH" --json url --jq .url)
            echo "PR already exists for $HEAD_BRANCH: $PR_URL"
          else
            PR_URL=$(gh_retry gh pr create \
            --base "$BASE_BRANCH" \
            --head "$HEAD_BRANCH" \
            --title "$TITLE" \
            --body-file "$BODY_FILE")
            echo "Created PR: $PR_URL"
          fi
          gh_retry gh label create "dependencies" --color "0B3D2E" --description "dependency updates" >/dev/null 2>&1 || true
          gh_retry gh label create "externpro" --color "0B3D2E" --description "externpro updates" >/dev/null 2>&1 || true
          gh_retry gh label create "release:tag" --color "FF6A00" --description "Tag release on merge" >/dev/null 2>&1 || true
          gh_retry gh pr edit "$PR_URL" --add-label "dependencies" >/dev/null 2>&1 || echo "Label 'dependencies' not found; skipping"
          gh_retry gh pr edit "$PR_URL" --add-label "externpro" >/dev/null 2>&1 || echo "Label 'externpro' not found; skipping"
          # Close superseded PRs from previous runs.
          # Criteria:
          # - head branch name starts with externpro-update-
          # - label includes externpro (if labels are available)
          # - head branch is not the current HEAD_BRANCH
          SUPERSEDED_PRS=$(gh_retry gh pr list --state open --json number,headRefName,labels --jq '.[] | select(.headRefName | startswith("externpro-update-")) | select(.headRefName != env.HEAD_BRANCH) | select(((.labels // []) | map(.name) | index("externpro")) != null) | "\(.number) \(.headRefName)"')
          if [ -n "$SUPERSEDED_PRS" ]; then
            while IFS= read -r pr; do
              [ -z "$pr" ] && continue
              PR_NUMBER=$(printf '%s' "$pr" | awk '{print $1}')
              SUPERSEDED_HEAD_REF=$(printf '%s' "$pr" | awk '{print $2}')
              if [ -z "$PR_NUMBER" ] || [ -z "$SUPERSEDED_HEAD_REF" ]; then
                continue
              fi
              gh_retry gh pr close "$PR_NUMBER" --comment "Superseded by $PR_URL" >/dev/null 2>&1 || echo "Failed to close PR #$PR_NUMBER"
              if [ "$SUPERSEDED_HEAD_REF" = "$HEAD_BRANCH" ]; then
                continue
              fi
              case "$SUPERSEDED_HEAD_REF" in
                externpro-update-*)
                  REF_ENC=$(printf '%s' "$SUPERSEDED_HEAD_REF" | sed 's|/|%2F|g')
                  if gh_retry gh api -X DELETE "repos/${{ github.repository }}/git/refs/heads/${REF_ENC}" >/dev/null 2>&1; then
                    echo "Deleted superseded branch: $SUPERSEDED_HEAD_REF"
                  else
                    echo "Could not delete branch '$SUPERSEDED_HEAD_REF' (missing/protected/insufficient permissions); skipping"
                  fi
                  ;;
                *)
                  echo "Refusing to delete non-automation branch '$SUPERSEDED_HEAD_REF' from superseded PR #$PR_NUMBER"
                  ;;
              esac
            done <<< "$SUPERSEDED_PRS"
          fi
