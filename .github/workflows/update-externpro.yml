name: Update externpro Submodule
on:
  workflow_call:
    inputs:
      submodule_path:
        description: 'Path to externpro submodule'
        required: false
        type: string
        default: '.devcontainer'
      target_ref:
        description: 'Branch or tag to update externpro to (e.g., "main" or "25.07.4")'
        required: false
        type: string
        default: 'main'
      preserve_existing_branches:
        description: 'Whether to preserve existing branches in caller workflows (default: use branches from wf-templates)'
        required: false
        type: boolean
        default: false
      create_pr:
        description: 'Whether to create a pull request'
        required: false
        type: boolean
        default: true
    secrets:
      workflow_write_token:
        description: 'Optional token with permission to update .github/workflows (PAT or fine-grained token). If not set, uses GITHUB_TOKEN.'
        required: false
jobs:
  externpro:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      -
        name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # fetches all history
          fetch-tags: true # explicitly fetches tags
          submodules: true
          token: ${{ secrets.workflow_write_token || github.token }}
      -
        name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      -
        name: Validate externpro submodule
        id: validate
        run: |
          SUBMODULE_PATH="${{ inputs.submodule_path }}"
          # Check if .gitmodules exists
          if [ ! -f ".gitmodules" ]; then
            echo "Error: .gitmodules file not found"
            exit 1
          fi
          # Check if submodule exists in .gitmodules
          if ! grep -q "path = $SUBMODULE_PATH" .gitmodules; then
            echo "Error: Submodule path $SUBMODULE_PATH not found in .gitmodules"
            exit 1
          fi
          # Check if submodule directory exists
          if [ ! -d "$SUBMODULE_PATH" ]; then
            echo "Error: Submodule directory $SUBMODULE_PATH does not exist"
            exit 1
          fi
          # Check if it's actually a git repository (submodule)
          if [ ! -e "$SUBMODULE_PATH/.git" ]; then
            echo "Error: $SUBMODULE_PATH is not a git submodule"
            exit 1
          fi
          if ! git -C "$SUBMODULE_PATH" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
            echo "Error: $SUBMODULE_PATH is not a valid git work tree"
            exit 1
          fi
          # Get submodule URL to verify it's externpro
          SUBMODULE_URL=$(git config -f .gitmodules --get submodule.$SUBMODULE_PATH.url)
          if [[ "$SUBMODULE_URL" != *"externpro/externpro"* ]]; then
            echo "Error: Submodule URL does not point to externpro/externpro: $SUBMODULE_URL"
            exit 1
          fi
          echo "✓ externpro submodule validation passed"
          echo "submodule_path=$SUBMODULE_PATH" >> $GITHUB_OUTPUT
      -
        name: Get current externpro HEAD
        id: current_head
        run: |
          cd "${{ steps.validate.outputs.submodule_path }}"
          CURRENT_HEAD=$(git rev-parse HEAD)
          echo "current_head=$CURRENT_HEAD" >> $GITHUB_OUTPUT
          echo "Current externpro HEAD: $CURRENT_HEAD"
      -
        name: Update externpro submodule
        id: update
        run: |
          cd "${{ steps.validate.outputs.submodule_path }}"
          TARGET_REF="${{ inputs.target_ref }}"
          # Fetch latest changes
          git fetch origin
          # Check if target_ref is a tag or branch
          if git rev-parse --verify "origin/$TARGET_REF" >/dev/null 2>&1; then
            # It's a branch
            TARGET_TYPE="branch"
            echo "target_type=branch" >> $GITHUB_OUTPUT
            LATEST_HEAD=$(git rev-parse origin/"$TARGET_REF")
          elif git rev-parse --verify "$TARGET_REF" >/dev/null 2>&1; then
            # It's a tag or commit
            LATEST_HEAD=$(git rev-parse "$TARGET_REF")
            TARGET_TYPE="tag"
            echo "target_type=tag" >> $GITHUB_OUTPUT
          else
            echo "Error: Target ref '$TARGET_REF' not found"
            exit 1
          fi
          echo "latest_head=$LATEST_HEAD" >> $GITHUB_OUTPUT
          echo "Target ref: $TARGET_REF ($TARGET_TYPE)"
          echo "Latest externpro HEAD: $LATEST_HEAD"
          # Check if update is needed
          if [ "${{ steps.current_head.outputs.current_head }}" = "$LATEST_HEAD" ]; then
            echo "externpro submodule is already at target ref"
            echo "update_needed=false" >> $GITHUB_OUTPUT
          else
            echo "externpro submodule needs update"
            echo "update_needed=true" >> $GITHUB_OUTPUT
            # Update to target
            if [ "$TARGET_TYPE" = "branch" ]; then
              git checkout -B "$TARGET_REF" "origin/$TARGET_REF"
            else
              git checkout --detach "$LATEST_HEAD"
            fi
          fi
      -
        name: Get externpro version tag
        id: version
        run: |
          cd "${{ steps.validate.outputs.submodule_path }}"
          VERSION_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "no-tag")
          DESCRIBE=$(git describe --tags 2>/dev/null || git rev-parse --short HEAD)
          echo "version_tag=$VERSION_TAG" >> $GITHUB_OUTPUT
          echo "describe=$DESCRIBE" >> $GITHUB_OUTPUT
          echo "externpro version: $VERSION_TAG"
          echo "externpro describe: $DESCRIBE"
      -
        name: Stage submodule update
        id: stage_submodule
        if: steps.update.outputs.update_needed == 'true'
        run: |
          # Stage submodule changes
          git add "${{ steps.validate.outputs.submodule_path }}"
          if git diff --cached --quiet -- "${{ steps.validate.outputs.submodule_path }}"; then
            echo "✓ No submodule changes staged for ${{ steps.validate.outputs.submodule_path }}"
          else
            echo "✓ Staged submodule update for ${{ steps.validate.outputs.submodule_path }}"
          fi
      -
        name: Update caller workflows
        id: update_workflows
        if: ${{ always() && inputs.create_pr }}
        uses: ./.devcontainer/.github/actions/sync-caller-workflows
        with:
          workflow_dir: .github/workflows
          template_dir: ${{ steps.validate.outputs.submodule_path }}/.github/wf-templates
          preserve_existing_branches: ${{ inputs.preserve_existing_branches }}
      -
        name: Determine if PR is needed
        id: pr_needed
        if: inputs.create_pr
        run: |
          if git diff --cached --quiet; then
            echo "pr_needed=false" >> $GITHUB_OUTPUT
            echo "No staged changes (no PR needed)"
          else
            echo "pr_needed=true" >> $GITHUB_OUTPUT
            echo "Staged changes detected (PR needed)"
          fi
      -
        name: Create branch
        id: branch
        if: inputs.create_pr && steps.pr_needed.outputs.pr_needed == 'true'
        run: |
          # Create branch using describe (instead of timestamp)
          DESCRIBE="${{ steps.version.outputs.describe }}"
          # Clean describe for branch name (remove invalid chars)
          BRANCH_NAME="externpro-update-$(echo "$DESCRIBE" | sed 's/[^a-zA-Z0-9.-]/-/g')"
          git checkout -b "$BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
      -
        name: Commit submodule update
        if: steps.update.outputs.update_needed == 'true' && inputs.create_pr && steps.pr_needed.outputs.pr_needed == 'true'
        run: |
          COMMIT_MSG="externpro ${{ steps.version.outputs.describe }}"
          git commit -m "$COMMIT_MSG" -- "${{ steps.validate.outputs.submodule_path }}"
          echo "Commit created: $COMMIT_MSG"
      -
        name: Commit and push workflow updates
        if: inputs.create_pr && steps.pr_needed.outputs.pr_needed == 'true'
        run: |
          if ! git diff --cached --quiet; then
            COMMIT_MSG="externpro ${{ steps.version.outputs.describe }} workflow updates"
            git commit -m "$COMMIT_MSG"
            echo "Commit created: $COMMIT_MSG"
          fi
          git push --set-upstream origin "${{ steps.branch.outputs.branch_name }}"
      -
        name: Create Pull Request
        if: inputs.create_pr && steps.pr_needed.outputs.pr_needed == 'true'
        env:
          GH_TOKEN: ${{ secrets.workflow_write_token || github.token }}
        run: |
          set -euo pipefail
          BASE_BRANCH="${{ github.event.repository.default_branch }}"
          HEAD_BRANCH="${{ steps.branch.outputs.branch_name }}"
          TITLE="externpro ${{ steps.version.outputs.describe }}"
          BODY_FILE="/tmp/pr-body.md"
          : > "$BODY_FILE"
          echo "## Summary" >> "$BODY_FILE"
          echo >> "$BODY_FILE"
          if [ "${{ steps.update.outputs.update_needed }}" = "true" ]; then
            echo "Update externpro submodule to \`${{ steps.version.outputs.describe }}\`" >> "$BODY_FILE"
          else
            echo "Sync caller workflows from templates" >> "$BODY_FILE"
          fi
          echo >> "$BODY_FILE"
          echo "## Changes" >> "$BODY_FILE"
          echo >> "$BODY_FILE"
          if [ "${{ steps.update.outputs.update_needed }}" = "true" ]; then
            echo "- Updated \`${{ steps.validate.outputs.submodule_path }}\` to externpro \`${{ steps.version.outputs.describe }}\`" >> "$BODY_FILE"
            echo "- Previous HEAD: \`${{ steps.current_head.outputs.current_head }}\`" >> "$BODY_FILE"
            echo "- New HEAD: \`${{ steps.update.outputs.latest_head }}\`" >> "$BODY_FILE"
          fi
          if [ "${{ steps.update_workflows.outputs.workflows_updated }}" = "true" ]; then
            echo "- Updated caller workflows to match templates" >> "$BODY_FILE"
          fi
          if [ -n "${{ steps.update_workflows.outputs.workflow_report }}" ]; then
            echo >> "$BODY_FILE"
            echo "### Workflow Update Report" >> "$BODY_FILE"
            echo >> "$BODY_FILE"
            echo "${{ steps.update_workflows.outputs.workflow_report }}" >> "$BODY_FILE"
          fi
          echo >> "$BODY_FILE"
          echo "---" >> "$BODY_FILE"
          echo >> "$BODY_FILE"
          echo "*This PR was created automatically by GitHub Actions*" >> "$BODY_FILE"
          if gh pr view "$HEAD_BRANCH" --json url --jq .url >/dev/null 2>&1; then
            PR_URL=$(gh pr view "$HEAD_BRANCH" --json url --jq .url)
            echo "PR already exists for $HEAD_BRANCH: $PR_URL"
          else
            PR_URL=$(gh pr create \
            --base "$BASE_BRANCH" \
            --head "$HEAD_BRANCH" \
            --title "$TITLE" \
            --body-file "$BODY_FILE")
            echo "Created PR: $PR_URL"
          fi
          gh pr edit "$PR_URL" --add-label "dependencies" >/dev/null 2>&1 || echo "Label 'dependencies' not found; skipping"
          gh pr edit "$PR_URL" --add-label "externpro" >/dev/null 2>&1 || echo "Label 'externpro' not found; skipping"
