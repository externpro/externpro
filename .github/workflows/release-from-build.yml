name: Upload Release Assets
# This reusable workflow requires the following permissions to be set by the caller:
# permissions:
#   contents: write     # Required for creating releases and uploading assets
#   id-token: write     # Required for OIDC token generation
#   attestations: write # Required for uploading attestations
on:
  workflow_call:
    inputs:
      workflow_run_url:
        description: 'URL of the workflow run to download artifacts from (e.g., https://github.com/owner/repo/actions/runs/123456789)'
        required: true
        type: string
      artifact_pattern:
        description: 'Pattern to match artifact files (e.g., "*.tar.xz")'
        required: false
        type: string
        default: '*.tar.xz'
      release_body_template:
        description: 'Template for the release body'
        required: false
        type: string
        default: |
          ## Release Notes

          This release includes build artifacts from workflow run:
          {workflow_run_url}

          ### Download
          - Download the appropriate `.tar.xz` file for your platform
    outputs:
      release_id:
        description: 'The ID of the release'
        value: ${{ jobs.upload-assets.outputs.release_id }}
      release_url:
        description: 'The URL of the release'
        value: ${{ jobs.upload-assets.outputs.release_url }}
      release_tag:
        description: 'The tag used for the release'
        value: ${{ jobs.upload-assets.outputs.release_tag }}
      is_prerelease:
        description: 'Whether the release is a prerelease'
        value: ${{ jobs.upload-assets.outputs.is_prerelease }}
jobs:
  upload-assets:
    runs-on: ubuntu-latest
    # Note: Permissions must be set by the caller workflow
    outputs:
      release_id: ${{ steps.create_release.outputs.release_id }}
      release_url: ${{ steps.create_release.outputs.release_url }}
      release_tag: ${{ steps.find_artifacts.outputs.tag }}
      is_prerelease: ${{ steps.find_artifacts.outputs.is_prerelease }}
    steps:
      -
        name: Checkout repository
        uses: actions/checkout@v4
      -
        name: Extract run ID from URL
        id: extract_run_id
        run: |
          run_url="${{ inputs.workflow_run_url }}"
          if [[ "$run_url" =~ /actions/runs/([0-9]+) ]]; then
            run_id="${BASH_REMATCH[1]}"
            echo "run_id=$run_id" >> $GITHUB_OUTPUT
            echo "Extracted run ID: $run_id"
          else
            echo "::error::Invalid workflow run URL format. Expected: https://github.com/owner/repo/actions/runs/123456789"
            exit 1
          fi
      -
        name: Download artifacts from workflow run
        run: |
          echo "Downloading artifacts from run ID: ${{ steps.extract_run_id.outputs.run_id }}"
          gh run download ${{ steps.extract_run_id.outputs.run_id }} --dir ./artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      -
        name: Find and prepare artifacts for upload
        id: find_artifacts
        run: |
          echo "Finding artifacts matching pattern: ${{ inputs.artifact_pattern }}"
          artifacts=()
          hashes=()
          # Find all files matching the pattern
          while IFS= read -r -d '' file; do
            if [[ -f "$file" ]]; then
              # Get the actual file path (in case it's inside a directory with the same name)
              actual_file=$(find "$(dirname "$file")" -type f -name "$(basename "$file")" -not -path "*/.*" | head -1)
              if [[ -f "$actual_file" ]]; then
                echo "Found artifact: $actual_file"
                artifacts+=("$actual_file")
                # Calculate SHA256 hash
                hash=$(sha256sum "$actual_file" | cut -d' ' -f1)
                filename=$(basename "$actual_file")
                hashes+=("$hash  $filename")
                echo "SHA256 ($filename): $hash"
              fi
            fi
          done < <(find ./artifacts -name "${{ inputs.artifact_pattern }}" -type f -print0)
          if [ ${#artifacts[@]} -eq 0 ]; then
            echo "::error::No artifacts found matching pattern: ${{ inputs.artifact_pattern }}"
            exit 1
          fi
          # Create SHA256SUMS file (kept for attestations, but not uploaded)
          sha256sums_file="./artifacts/SHA256SUMS"
          printf '%s\n' "${hashes[@]}" | LC_ALL=C sort -k2,2 > "${sha256sums_file}"
          mapfile -t manifest_files < <(find ./artifacts -name "*.manifest.cmake" -type f | sort)
          if [ ${#manifest_files[@]} -eq 0 ]; then
            echo "::error::No manifest file found in downloaded artifacts (expected: *.manifest.cmake)"
            find ./artifacts -type f | sort
            exit 1
          fi
          manifest_file="${manifest_files[0]}"
          if [ ${#manifest_files[@]} -gt 1 ]; then
            echo "Found ${#manifest_files[@]} manifest files; verifying they are identical"
            ref_hash=$(tr -d '\r' < "${manifest_file}" | sha256sum | cut -d' ' -f1)
            for f in "${manifest_files[@]}"; do
              h=$(tr -d '\r' < "$f" | sha256sum | cut -d' ' -f1)
              if [ "$h" != "$ref_hash" ]; then
                echo "::error::Manifest files differ: '$manifest_file' ($ref_hash) vs '$f' ($h)" >&2
                exit 1
              fi
            done
          fi
          tr -d '\r' < "${manifest_file}" > "${manifest_file}.lf"
          mv "${manifest_file}.lf" "${manifest_file}"
          version_tag=$(grep -E '^set\(XP_MANIFEST_TAG ' "${manifest_file}" | head -1 | sed -E 's/^set\(XP_MANIFEST_TAG "?([^\)"]+)"?\).*/\1/')
          if [ -z "${version_tag}" ]; then
            echo "::error::Could not read XP_MANIFEST_TAG from manifest: ${manifest_file}"
            exit 1
          fi
          echo "Manifest: ${manifest_file}"
          echo "Extracted version tag: ${version_tag}"
          if [[ "${version_tag}" =~ -[0-9]+-g[a-f0-9]+$ ]]; then
            is_prerelease="true"
          else
            is_prerelease="false"
          fi
          mapfile -t sorted_hashes < <(printf '%s\n' "${hashes[@]}" | LC_ALL=C sort -k2,2)
          for entry in "${sorted_hashes[@]}"; do
            hash="${entry%%  *}"
            fname="${entry#*  }"
            norm=$(printf '%s' "${fname}" | sed -E 's/[^A-Za-z0-9]/_/g')
            printf 'list(APPEND XP_MANIFEST_ARTIFACTS "%s")\n' "${fname}" >> "${manifest_file}"
            printf 'set(XP_ARTIFACT_SHA256__%s "%s")\n' "${norm}" "${hash}" >> "${manifest_file}"
          done
          manifest_hash=$(sha256sum "${manifest_file}" | cut -d' ' -f1)
          manifest_name=$(basename "${manifest_file}")
          printf '%s  %s\n' "${manifest_hash}" "${manifest_name}" >> "${sha256sums_file}"
          LC_ALL=C sort -k2,2 -o "${sha256sums_file}" "${sha256sums_file}"
          sha256sums_hash=$(sha256sum "${sha256sums_file}" | cut -d' ' -f1)
          # Set outputs - use environment file method for better reliability
          {
            echo "artifacts<<EOF"
            printf '%s\n' "${artifacts[@]}"
            echo "EOF"
            echo "sha256sums_file=$sha256sums_file"
            echo "sha256sums_hash=$sha256sums_hash"
            echo "tag=$version_tag"
            echo "is_prerelease=$is_prerelease"
            echo "manifest_file=$manifest_file"
            echo "manifest_hash=$manifest_hash"
          } >> $GITHUB_OUTPUT
      - name: Attest artifacts
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ github.repository }}@${{ steps.find_artifacts.outputs.tag }}
          subject-checksums: ${{ steps.find_artifacts.outputs.sha256sums_file }}
          push-to-registry: false
      -
        name: Check if tag exists
        id: check_tag
        run: |
          tag="${{ steps.find_artifacts.outputs.tag }}"
          echo "Checking if tag exists: $tag"
          if gh release view "$tag" &>/dev/null; then
            echo "::error::Release for tag $tag already exists. This workflow is configured to fail if the release already exists."
            exit 1
          else
            echo "Release does not exist for tag: $tag"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      -
        name: Create release
        id: create_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          tag="${{ steps.find_artifacts.outputs.tag }}"
          is_prerelease="${{ steps.find_artifacts.outputs.is_prerelease }}"
          release_name="$tag"
          # Create a temporary file for the release notes
          RELEASE_NOTES_FILE=$(mktemp)
          # Write base release body to file
          cat << 'EOF' > "$RELEASE_NOTES_FILE"
          ${{ inputs.release_body_template }}

          ### Build Provenance
          This release includes SLSA build provenance attestations, which provide verifiable information about how these artifacts were built.

          **Release Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

          You can find the attestations in the "Attestations" section of the release workflow run linked above.

          To verify the attestations, you can use the GitHub CLI:
          ```bash
          gh attestation verify --repo ${{ github.repository }} --signer-repo {signer_repo} <artifact-filename>
          ```
          EOF
          # Replace placeholders in the file
          # Use the hardcoded repository where this workflow is defined as the signer
          sed -i "s|{workflow_run_url}|${{ inputs.workflow_run_url }}|g" "$RELEASE_NOTES_FILE"
          sed -i "s|{signer_repo}|externpro/externpro|g" "$RELEASE_NOTES_FILE"
          # Append checksums section to release notes file
          cat << 'EOF' >> "$RELEASE_NOTES_FILE"
          ### Manifest
          ```
          EOF
          echo "MANIFEST_SHA256 ${{ steps.find_artifacts.outputs.manifest_hash }}" >> "$RELEASE_NOTES_FILE"
          # Close the code block
          echo '```' >> "$RELEASE_NOTES_FILE"
          # Set flags based on release type
          flags=""
          if [ "$is_prerelease" = "true" ]; then
            flags="$flags --prerelease"
          fi
          # Always create draft releases
          flags="$flags --draft"
          # Create the release using the file for notes
          echo "Creating release for tag: $tag"
          release_output=$(gh release create "$tag" \
            --title "$release_name" \
            --notes-file "$RELEASE_NOTES_FILE" \
            $flags 2>&1)
          # Clean up temp file
          rm -f "$RELEASE_NOTES_FILE"
          # Extract the release URL from the output
          if echo "$release_output" | grep -q "https://github.com"; then
            release_url=$(echo "$release_output" | grep -o 'https://github.com[^[:space:]]*' | head -1)
            echo "Release URL: $release_url"
            # Extract the release ID from the URL
            if [[ "$release_url" =~ /releases/tag/([^/]+)$ ]]; then
              tag_or_id="${BASH_REMATCH[1]}"
              # Try to get the release ID using the tag or untagged ID
              if [[ "$tag_or_id" == untagged-* ]]; then
                # For untagged releases, we need to list all releases and find by URL
                echo "Handling untagged release: $tag_or_id"
                release_id=$(gh api repos/$GITHUB_REPOSITORY/releases --jq ".[] | select(.html_url == \"$release_url\") | .id")
              else
                # For tagged releases, we can query directly
                release_id=$(gh api repos/$GITHUB_REPOSITORY/releases/tags/$tag --jq '.id')
              fi
            else
              echo "Warning: Could not extract tag or ID from URL: $release_url"
              release_id="unknown"
            fi
          else
            echo "Warning: Could not extract release URL from output"
            release_url="https://github.com/$GITHUB_REPOSITORY/releases"
            release_id="unknown"
          fi
          # Set outputs
          echo "release_id=$release_id" >> $GITHUB_OUTPUT
          echo "release_url=$release_url" >> $GITHUB_OUTPUT
          echo "Created release: $tag"
      -
        name: Upload artifacts to release
        run: |
          tag="${{ steps.find_artifacts.outputs.tag }}"
          echo "Uploading artifacts to release: $tag"
          while IFS= read -r artifact; do
            if [ -n "$artifact" ] && [ -f "$artifact" ]; then
              echo "Uploading artifact: $artifact"
              gh release upload "$tag" "$artifact" --clobber
            fi
          done <<< "${{ steps.find_artifacts.outputs.artifacts }}"
          manifest_file="${{ steps.find_artifacts.outputs.manifest_file }}"
          if [ -n "$manifest_file" ] && [ -f "$manifest_file" ]; then
            echo "Uploading manifest file: $manifest_file"
            gh release upload "$tag" "$manifest_file" --clobber
          else
            echo "WARNING: manifest file not found at: $manifest_file"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      -
        name: List release assets
        run: |
          tag="${{ steps.find_artifacts.outputs.tag }}"
          echo "Release assets for $tag:"
          gh release view "$tag" --json assets | jq -r '.assets[] | "- \(.name) (\(.size) bytes)"'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
